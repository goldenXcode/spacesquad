package AlgorithmTest;

/*
	A basic extension of the java.applet.Applet class
 */

import java.awt.*;
import java.applet.*;
import java.util.*;
import java.awt.event.*;
import javax.swing.*;

public class AlgorithmTest extends Applet implements Runnable
{
	public void init()
	{			
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setLayout(new BorderLayout(0,0));
		setSize(640,480);
		CenterPanel.setLayout(new GridLayout(1,1,0,0));
		add(BorderLayout.CENTER, CenterPanel);
		CenterPanel.add(Scene);
		NorthPanel.setLayout(new GridLayout(1,1,0,0));
		add(BorderLayout.NORTH,NorthPanel);
		MapControl.setLayout(new BoxLayout(MapControl,BoxLayout.X_AXIS));
		NorthPanel.add(MapControl);
		MapControl.setBackground(java.awt.Color.lightGray);
		lbl_Map.setText(" Map:");
		MapControl.add(lbl_Map);
		Empty.setCheckboxGroup(Group1);
		Empty.setState(true);
		Empty.setLabel("Empty");
		MapControl.add(Empty);
		Medium.setCheckboxGroup(Group1);
		Medium.setLabel("Medium");
		MapControl.add(Medium);
		Hard.setCheckboxGroup(Group1);
		Hard.setLabel("Hard");
		MapControl.add(Hard);
		Impossible.setCheckboxGroup(Group1);
		Impossible.setLabel("Impossible");
		MapControl.add(Impossible);
		rbt_Start.setCheckboxGroup(Group1);
		rbt_Start.setLabel("Start");
		MapControl.add(rbt_Start);
		rbt_Start.setForeground(new java.awt.Color(0,128,0));
		rbt_Finish.setCheckboxGroup(Group1);
		rbt_Finish.setLabel("Finish");
		MapControl.add(rbt_Finish);
		rbt_Finish.setForeground(java.awt.Color.red);
		lbl_Speed.setText("Speed:");
		MapControl.add(lbl_Speed);
		MapControl.add(Speed);
		EastPanel.setLayout(new GridBagLayout());
		add(BorderLayout.EAST,EastPanel);
		EastPanel.setBackground(java.awt.Color.lightGray);
		panel1.setLayout(new BorderLayout(0,0));
		
		EastPanel.add(panel1, new GridBagConstraints(0,0,1,1,1.0,0.2,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
		lbl_Algorithm.setText("Algorithm:");
		panel1.add(BorderLayout.NORTH, lbl_Algorithm);
		Algorithm.addItem("A*");
		try {
			Algorithm.select(0);
		}
		catch (IllegalArgumentException e) { }
		panel1.add(BorderLayout.CENTER, Algorithm);
		panel3.setLayout(new BorderLayout(0,0));
		EastPanel.add(panel3, new GridBagConstraints(0,1,1,1,1.0,0.2,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
		lbl_Distance.setText("Distance Fkt.");
		panel3.add(BorderLayout.NORTH,lbl_Distance);
		Distance_Fkt.addItem("Max(dx, dy)");
		Distance_Fkt.addItem("Euclidean");
		Distance_Fkt.addItem("Diagonal");
		Distance_Fkt.addItem("Manhattan");
		try {
			Distance_Fkt.select(3);
		}
		catch (IllegalArgumentException e) { }
		panel3.add(BorderLayout.SOUTH,Distance_Fkt);
		panel2.setLayout(new GridBagLayout());
		EastPanel.add(panel2, new GridBagConstraints(0,4,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
		bt_Start.setLabel("Start");
		panel2.add(bt_Start,new GridBagConstraints(0,0,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),8,0));
		bt_Reset.setLabel("Reset / Abort");
		panel2.add(bt_Reset,new GridBagConstraints(0,1,1,1,0.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
		bt_Clear.setLabel("Clear");
		panel2.add(bt_Clear, new GridBagConstraints(0,2,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
		panel4.setLayout(new GridBagLayout());
		EastPanel.add(panel4, new GridBagConstraints(0,3,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
		label1.setText("Heuristic Cost:");
		panel4.add(label1,new GridBagConstraints(0,0,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,2,0,0),5,5));
		panel4.add(heuristicCost,new GridBagConstraints(0,1,1,1,1.0,1.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.BOTH,new Insets(0,0,0,0),0,5));
		lbl_Cost.setText("actCost");
		panel4.add(lbl_Cost, new GridBagConstraints(0,2,1,1,0.0,0.0,java.awt.GridBagConstraints.CENTER,java.awt.GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
		//}}				
	
		//{{REGISTER_LISTENERS
		SymItem lSymItem = new SymItem();
		Empty.addItemListener(lSymItem);
		Medium.addItemListener(lSymItem);
		Hard.addItemListener(lSymItem);
		Impossible.addItemListener(lSymItem);
		SymMouse aSymMouse = new SymMouse();
		Scene.addMouseListener(aSymMouse);
		SymMouseMotion aSymMouseMotion = new SymMouseMotion();
		Scene.addMouseMotionListener(aSymMouseMotion);
		SymAction lSymAction = new SymAction();
		bt_Start.addActionListener(lSymAction);
		SymAdjustment lSymAdjustment = new SymAdjustment();
		Speed.addAdjustmentListener(lSymAdjustment);
		rbt_Finish.addItemListener(lSymItem);
		rbt_Start.addItemListener(lSymItem);
		bt_Reset.addActionListener(lSymAction);
		bt_Clear.addActionListener(lSymAction);
		heuristicCost.addAdjustmentListener(lSymAdjustment);
		//}}
		
		initObjects();
	}
	
	/**
	 * initObjects initalizes all additional Objects for the applet
	 */
	public void initObjects()
	{
		//
        // Create the initial doublebuffer 
        //
        
        m_buffer = createImage( (int) getBounds().getWidth(), (int) getBounds().getHeight() );
        m_db = m_buffer.getGraphics();                

		ResizeScene();

        lbl_Cost.setText("Cost: " + m_estimateCost);

        //
        // Create the initial search algorithm
        //
        int Function = Distance_Fkt.getSelectedIndex();
        m_algorithm = new AStar(m_TilesX, m_TilesY, this);        

		//
		// Start the simulation thread
		// 
		
        if (m_Thread == null)
        {
            m_Thread = new Thread(this);
            m_Running = true;
            m_Thread.start();
        }      
	}
	
	public void run()
    {
    	while (m_Running)
    	{
    		if (m_StartSearch)
        	{
        		Vector path;
        		
        		m_StartSearch = false;
        		
        		int Function = Distance_Fkt.getSelectedIndex();        		        		
		
				if ((m_Start != null) && (m_Finish != null))
				{
				    m_algorithm.setCost(m_estimateCost);
		            m_algorithm.setFunction(Function);
		            m_algorithm.setWait(m_Wait);		            
				    
					path = m_algorithm.findPath(m_Scene, m_Start, m_Finish);
				}
        	}
        	
    		repaint();	
    		
    		try
			{
            	Thread.sleep(25);
            }
            catch(InterruptedException e) {}
    	}
    	
    	m_Thread = null;
    }
	
	public void destroy()
    {
        m_Running = false;
        
        // Kurz Warten, damit der Thread auch beendet wird, 
        // bevor der DoubleBuffer gelöscht wurde
        while (m_Thread != null)
        {
        	
            try
            {
                Thread.sleep(40);
            }
            catch(InterruptedException e) {}        
        }
    }
	
	
	public void update(Graphics g)
    {
    	int sizeX = Scene.getSize().width;
        int sizeY = Scene.getSize().height;

		//
        // Doublebuffer auf Fenstergrösse anpassen
        //
        if (m_buffer.getWidth(null) != sizeX || m_buffer.getHeight(null) != sizeY)
        {

            if (sizeX <= 0) sizeX = 1;
            if (sizeY <= 0) sizeY = 1;
            
            m_buffer = createImage(sizeX,sizeY);
            m_db = m_buffer.getGraphics();
        }
        else
        {
            m_db.setColor(Color.white);
            m_db.clearRect(0, 0, m_buffer.getWidth(null), m_buffer.getHeight(null));
        }

        paint(m_db);
        
        Scene.getGraphics().drawImage(m_buffer, 0, 0, this);
    }
	
	public void paint(Graphics g)
	{
		// Repaint the Scene on the Screen
		Node	info;
		Color	drawColor;
		int		lastCost = 0;
				
		// Draw the single tiles
		for (int y = 0; y < m_TilesY; y++)
		{
			for (int x = 0; x < m_TilesX; x++)
			{
				info = (Node) m_Scene.elementAt(y * m_TilesX + x);
				
				if (info.cost != lastCost)
				{
					switch (info.cost)
					{
						case Node.COST_NONE:
							drawColor = CEmpty;
							break;
						case Node.COST_MEDIUM:
							drawColor = CMedium;
							break;
						case Node.COST_HARD:
							drawColor = CHard;
							break;
						default:
							drawColor = CImpossible;
					}
					lastCost = info.cost;
					g.setColor(drawColor);
				}				
				g.fillRect(x * m_SizeX, y * m_SizeY, m_SizeX - 1, m_SizeY - 1);
				
				// Check if the Node is in some list and needs extra drawing code
				if (info.list != Node.NO_LIST)
				{
					Color c = g.getColor();
					
					switch (info.list)
					{
						case Node.OPEN_LIST:
							g.setColor(Color.blue);
							break;
						case Node.CLOSED_LIST:
							g.setColor(Color.green);
							break;
						case Node.FINAL_PATH:
							g.setColor(Color.red);
							break;						
					}
					// Draw it a little bit smaller, so that the grid does not draw over it
					g.drawRect(x * m_SizeX + 2, y * m_SizeY + 2, m_SizeX - 4, m_SizeY - 4);
					
					// Draw a line to the parenting node if any exists
					if (info.parent != null)
					{
						g.setColor(Color.orange);
						
						g.drawLine(x * m_SizeX + m_SizeX / 2, y * m_SizeY + m_SizeY / 2, info.parent.posX * m_SizeX + m_SizeX / 2, info.parent.posY * m_SizeY + m_SizeY / 2);
					}
					
					g.setColor(c);
				}								
			}						
		}
		
		// Finally draw the starting and finishing nodes
		if (m_Finish != null)
		{ 
			int PosX = m_Finish.posX;
			int PosY = m_Finish.posY;
				
			g.setColor(Color.red);
			g.fillOval(PosX * m_SizeX + 2, PosY * m_SizeY + 2, m_SizeX - 2, m_SizeY - 2);
		}
				
		if (m_Start != null)
		{ 
			int PosX = m_Start.posX;
			int PosY = m_Start.posY;
				
			g.setColor(Color.green);
			g.fillOval(PosX * m_SizeX + 2, PosY * m_SizeY + 2, m_SizeX - 2, m_SizeY - 2);
		}
		
		// Draw a grid atop of the tiles
		g.setColor(Color.gray);
		
		// First vertical ...
		for (int x = 1; x <= m_TilesX; x++)
		{
			g.drawLine(x * m_SizeX, 0, x * m_SizeX, m_TilesY * m_SizeY);
		}
		// then horizontal
		for (int y = 1; y <= m_TilesY; y++)
		{
			g.drawLine(0, y * m_SizeY, m_TilesX * m_SizeX, y * m_SizeY);
		}
	}

	void ResizeScene()
	{
		Node temp;						
		
		if (m_Scene == null) 
		{
			m_Scene = new Vector(m_TilesX * m_TilesY, m_TilesX);
			
			// Build a new Scene
			for (int y = 0; y < m_TilesY; y++)
			{
				for (int x = 0; x < m_TilesX; x++)
				{
					temp = new Node(x, y);					
					m_Scene.add(y * m_TilesX + x, temp);
				}
			}
			
		}
		else
		{
			//Vector	temp = new Vector(m_SizeX * m_SizeY, m_SizeX);
			
			//m_Scene.setSize(m_SizeX * m_SizeY)
		}
			
		
	}

	void ResetScene()
	{
		Node temp;
		
		if (m_Scene == null) return;
		
		Iterator it = m_Scene.iterator();
		
		while (it.hasNext())
		{
			temp = (Node) it.next();
			temp.cost = 1;
			
			// Update the node information
			m_Scene.set(temp.posY * m_TilesX + temp.posX, temp);
		}
	}
	
	
	//{{DECLARE_CONTROLS
	java.awt.Panel CenterPanel = new java.awt.Panel();
	java.awt.Canvas Scene = new java.awt.Canvas();
	java.awt.Panel NorthPanel = new java.awt.Panel();
	java.awt.Panel MapControl = new java.awt.Panel();
	java.awt.Label lbl_Map = new java.awt.Label();
	java.awt.Checkbox Empty = new java.awt.Checkbox();
	java.awt.CheckboxGroup Group1 = new java.awt.CheckboxGroup();
	java.awt.Checkbox Medium = new java.awt.Checkbox();
	java.awt.Checkbox Hard = new java.awt.Checkbox();
	java.awt.Checkbox Impossible = new java.awt.Checkbox();
	java.awt.Checkbox rbt_Start = new java.awt.Checkbox();
	java.awt.Checkbox rbt_Finish = new java.awt.Checkbox();
	java.awt.Label lbl_Speed = new java.awt.Label();
	java.awt.Scrollbar Speed = new java.awt.Scrollbar(Scrollbar.HORIZONTAL,20,5,0,50);
	java.awt.Panel EastPanel = new java.awt.Panel();
	java.awt.Panel panel1 = new java.awt.Panel();
	java.awt.Label lbl_Algorithm = new java.awt.Label();
	java.awt.Choice Algorithm = new java.awt.Choice();
	java.awt.Panel panel3 = new java.awt.Panel();
	java.awt.Label lbl_Distance = new java.awt.Label();
	java.awt.Choice Distance_Fkt = new java.awt.Choice();
	java.awt.Panel panel2 = new java.awt.Panel();
	java.awt.Button bt_Start = new java.awt.Button();
	java.awt.Button bt_Reset = new java.awt.Button();
	java.awt.Button bt_Clear = new java.awt.Button();
	java.awt.Panel panel4 = new java.awt.Panel();
	java.awt.Label label1 = new java.awt.Label();
	java.awt.Scrollbar heuristicCost = new java.awt.Scrollbar(Scrollbar.HORIZONTAL,2,1,2,10);
	java.awt.Label lbl_Cost = new java.awt.Label();
	//}}	
	
	//////////////////////////////////////////////////////////////////////
	//
	//  VARIABLES
	//
	//////////////////////////////////////////////////////////////////////
	
	private static final Color CEmpty = Color.white;
	private static final Color CMedium = Color.lightGray;
	private static final Color CHard = Color.gray;
	private static final Color CImpossible = Color.black;
	
	protected boolean		m_AbortSearch = false;
	
	private Image			m_buffer = null;
    private Graphics		m_db = null;
	
	private Color			m_drawColor = CEmpty;
	
	private int             m_estimateCost = Node.COST_NONE;
	
	private int				m_NewCost = 1;
	private boolean 		m_Running = false;
    private Thread			m_Thread = null;    
			
	/** The Scene consists of a vector of Nodes. Each node represents a tile in the world. */
	private Vector			m_Scene = null;
	
	protected SearchAlgorithm   m_algorithm = null;
	
	private boolean			m_StartSearch = false;
	
	private int				m_SizeX = 20;
	private int				m_SizeY = 20;

	private Node			m_Start = null;
	private Node			m_Finish = null;
		
	private int				m_TilesX = 27;
	private int				m_TilesY = 22;

	private int				m_Wait = 100;

	class SymItem implements java.awt.event.ItemListener
	{
		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == Empty)
				Empty_ItemStateChanged(event);
			else if (object == Medium)
				Medium_ItemStateChanged(event);
			else if (object == Hard)
				Hard_ItemStateChanged(event);
			else if (object == Impossible)
				Impossible_ItemStateChanged(event);
			else if (object == rbt_Finish)
				rbtFinish_ItemStateChanged(event);
			else if (object == rbt_Start)
				rbtStart_ItemStateChanged(event);
		}
	}

	void Empty_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		if (Empty.getState() == true) 
		{	
			m_drawColor = CEmpty;		
			m_NewCost = Node.COST_NONE;
		}		
	}
	void Medium_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		if (Medium.getState() == true) 
		{
			m_drawColor = CMedium;				 
			m_NewCost = Node.COST_MEDIUM;
		}
	}
	void Hard_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		if (Hard.getState() == true) 
		{
			m_drawColor = CHard;
			m_NewCost = Node.COST_HARD;
		}			 
	}
	void Impossible_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		if (Impossible.getState() == true) 
		{
			m_drawColor = CHard;			 
			m_NewCost = Node.COST_IMPOSSIBLE;
		}
	}

	class SymMouse extends java.awt.event.MouseAdapter
	{
		public void mousePressed(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == Scene)
				Scene_MousePressed(event);
		}		
	}

	

	void Scene_MousePressed(java.awt.event.MouseEvent event)
	{
		Node info;		
		
		int x = event.getX();
		int y = event.getY();
		
		// Transform the screen corrdinate into tile coordinates
		x = x / m_SizeX;
		y = y / m_SizeY;
		
		if ((x < 0) || (x >= m_TilesX)) return;
		if ((y < 0) || (y >= m_TilesY)) return;
		
		// Update the cost info		
		if (m_NewCost >= 0)
		{
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			info.cost = m_NewCost;
			
			m_Scene.set(y * m_TilesX + x, info);	
		}
		else if (m_NewCost == -1)
		{
			// Update the finish node
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			if (info.cost != Node.COST_IMPOSSIBLE) m_Finish = info;
		}
		else if (m_NewCost == -2)
		{
			// Update the starting node
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			if (info.cost != Node.COST_IMPOSSIBLE) m_Start = info;
		}
		
		repaint();
	}

	class SymMouseMotion extends java.awt.event.MouseMotionAdapter
	{
		public void mouseDragged(java.awt.event.MouseEvent event)
		{
			Object object = event.getSource();
			if (object == Scene)
				Scene_MouseDragged(event);
		}
	}

	void Scene_MouseDragged(java.awt.event.MouseEvent event)
	{
		Node info;		
		
		int x = event.getX();
		int y = event.getY();
		
		// Transform the screen corrdinate into tile coordinates
		x = x / m_SizeX;
		y = y / m_SizeY;
		
		if ((x < 0) || (x >= m_TilesX)) return;
		if ((y < 0) || (y >= m_TilesY)) return;
		
		// Update the cost info
		if (m_NewCost >= 0)
		{
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			info.cost = m_NewCost;
			
			m_Scene.set(y * m_TilesX + x, info);	
		}
		else if (m_NewCost == -1)
		{
			// Update the finish node
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			if (info.cost != Node.COST_IMPOSSIBLE) m_Finish = info;
		}
		else if (m_NewCost == -2)
		{
			// Update the starting node
			info = (Node) m_Scene.elementAt(y * m_TilesX + x);
			
			if (info.cost != Node.COST_IMPOSSIBLE) m_Start = info;
		}
		
//		repaint();
			 
	}

	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (object == bt_Start)
				bt_bt_Start_ActionPerformed(event);
			else if (object == bt_Reset)
				btReset_ActionPerformed(event);
			else if (object == bt_Clear)
				btClear_ActionPerformed(event);
		}
	}

	void bt_bt_Start_ActionPerformed(java.awt.event.ActionEvent event)
	{
		int Function = Distance_Fkt.getSelectedIndex();
		
		Iterator it = m_Scene.iterator();
		Node info;
		while (it.hasNext())
		{
			info = (Node) it.next();
			info.list = Node.NO_LIST;
		}	
		
		// Start the Pathfinding Algorithm
		m_AbortSearch = false;
		m_StartSearch = true;
		
		/*AStar search = new AStar(m_Wait, m_TilesX, m_TilesY, Function, this);
		
		if (m_Start == null) return;
		if (m_Finish == null) return;
		
		Vector path = search.findPath(m_Scene, m_Start, m_Finish);
		*/
		
	}

	class SymAdjustment implements java.awt.event.AdjustmentListener
	{
		public void adjustmentValueChanged(java.awt.event.AdjustmentEvent event)
		{
			Object object = event.getSource();
			if (object == Speed)
				Speed_AdjustmentValueChanged(event);
			else if (object == heuristicCost)
				heuristicCost_AdjustmentValueChanged(event);
		}
	}

	void Speed_AdjustmentValueChanged(java.awt.event.AdjustmentEvent event)
	{
		m_Wait = (Speed.getMaximum()- Speed.getValue()) * 5;			 
	}

	void rbtFinish_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		// If the cost is -1 then set the finish point when clicked
		m_NewCost = -1;
	}

	void rbtStart_ItemStateChanged(java.awt.event.ItemEvent event)
	{
		// If the cost is -2 then set the starting point when clicked
		m_NewCost = -2;
			 
	}

	void btReset_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// Abort the current search
		m_AbortSearch = true;
		
		Iterator it = m_Scene.iterator();
		Node info;
		while (it.hasNext())
		{
			info = (Node) it.next();
			info.list = Node.NO_LIST;
			info.g = 0;
			info.f = 0;
			info.h = 0;			
		}			 
	}

	void btClear_ActionPerformed(java.awt.event.ActionEvent event)
	{
		// Abort the current search
		m_AbortSearch = true;
		
		Iterator it = m_Scene.iterator();
		Node info;
		while (it.hasNext())
		{
			info = (Node) it.next();
			info.list = Node.NO_LIST;
			info.cost = Node.COST_NONE;
			info.g = 0;
			info.f = 0;
			info.h = 0;			
		}		
			 
	}

	void heuristicCost_AdjustmentValueChanged(java.awt.event.AdjustmentEvent event)
	{
		// to do: code goes here.
		m_estimateCost = heuristicCost.getValue();
		
		lbl_Cost.setText("Cost: " + m_estimateCost);
	}
}

